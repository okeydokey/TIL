# MySQL 실행계획

출처 : [Real MySQL](https://wikibook.co.kr/real-mysql/)



### 쿼리 실행 절차

1. **[SQL 파싱]** 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리
   - SQL 파스 트리 생성
2. **[최적화 및 실행 계획 수립]** SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
   - 불필요한 조건 제거 및 복잡한 연산의 단순화
   - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
   - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
   - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴



### 실행 계획 분석

#### id

- 쿼리 문장에서 SELECT 키워드 단위로 구분한 '단위 SELECT 쿼리' 별로 부여되는 식별자 값. 조인되는 경우 같은 id가 부여됨

#### select_type

- SIMPLE

  - UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리
  - 단 하나만 존재

- PRIMARY

  - UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리
  - 단 하나만 존재

- UNION

  - UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리

- DEPENDENT UNION

  - 내부 쿼리가 외부의 값을 참조해서 처리되는 UNION

    ex) SELECT A.A FROM A WHERE A.A = **B.A**

- UNION RESULT

  - UNION의 결과를 담아두는 임시 테이블 

- SUBQUERY

  - FROM 절 이외에서 사용되는 서브 쿼리

- DEPENDENT SUBQUERY

  - 서브 쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 칼럼을 사용

- DERIVED

  - 서브 쿼리가 FROM 절에 사용된 경우
  - 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블(파생 테이블)을 생성, 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할때 성능상 불리할때가 많음

- UNCACHEABLE SUBQUERY

  - 조건이 똑같은 서브 쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브 쿼리 결과를 내부적인 캐시 공간에 담음
    - SUBQUERY는 바깥쪽(Outer) 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용
    - DEPENDENT SUBQUERY는 의존하는 바깥쪽(Outer) 쿼리의 칼럼의 값 단위로 캐시해두고 사용
  - UNCACHEABLE SUBQUERY는 서브 쿼리에 포함된 요소에 의해 캐시 자체가 불가능 한 경우
    - 사용자 변수가 서브 쿼리에 사용된 경우
    - NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브 쿼리 내에 사용된 경우
    - UUID()나 RAND()와 같이 결과값이 호출할때마다 달라지는 함수가 서브 쿼리에 사용된 경우

- UNCACHEABLE UNION

  

> 하나의 단위 SELECT 쿼리가 다른 단위 SELECT를 포함하고 있으면 이를 서브 쿼리라고 표현한다. 이처럼 서브 쿼리가 사용된 경우에는 외부(Outer) 쿼리보다 서브 쿼리가 먼저 실행되는 것이 일반적이며, 대부분이 이 방식이 반대의 경우보다 빠르게 처리된다. 하지만 DEPENDENT 키워드를 포함하는 서브 쿼리는 외부 쿼리에 의존적이므로 절대 외부 쿼리보다 먼저 싫애 될 수 없다. 그래서 DEPENDENT 키워드가 포함된 서브 쿼리는 비효율적인 경우가 많다.



##### 서브 쿼리

- 중접된 쿼리(Nested Query) : SELECT 되는 컬럼에 사용된 서브 쿼리
- 서브 쿼리(Sub Query) : WHERE 절에 사용된 경우
- 파생 테이블(Derived) : FROM 절에 사용된 서브 쿼리
- 스칼라 서브 쿼리 : 하나의 값만(컬럼이 단 하나인 레코드 1건) 반환하는 쿼리
- 로우 서브 쿼리 : 칼럼의 개수에 관계없이 하나의 레코드만 반환하는 쿼리

#### table

- MySQL의 실행 계획은 테이블 기준으로 표시 됨
- <derived> 또는 <union>과 같이 <> 로 둘러싸인 이름이 명시되는 경우 이 테이블은 임시 테이블을 의미, <> 안에 표시되는 숫자는 단위 SELECT 쿼리의 id를 지칭

#### type

- system

  - 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
  - innoDB 테이블에서는 사용되지 않음

- const

  - 레코드의 건수에 관계 없이 PK나 UK 칼럼을 이용하는 WHERE 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리의 처리 방식

    > 실행 계획의 type이 const인 실행 계획은 MySQL의 옵티마이저가 쿼리를 최적화 하는 단계에서 모두 상수화 한다.

    ```
    SELECT COUNT(*)
    FROM employees
    WHERE first_name = (SELECT first_name FROM employees e2 WHERE emp_no = 100001);
    ->
    SELECT COUNT(*)
    FROM employees
    WHERE first_name = 'Jasminko'
    ```

    

- eq_ref

  - 조인에서 처음 읽은 테이블의 컬럼 값을 그 다음 읽어야 할 테이블의 PK나 UK(NOT NULL) 컬럼의 검색 조건에 사용할 때

- ref

  - 인덱스 종류와 관계없이 동등 조건(=)으로 검색할 때 사용

- fulltext

  - 전문 검색 인덱스 사용

- ref_or_null

  - ref 접근 방식과 NULL 비교가 추가된 형태

- unique_subquery

  - WHERE 조건절에서 사용될 수 있는 IN (subquery) 형태의 쿼리를 위한 접근 방식, 서브 쿼리에서 중복되지 않은 유니크한 값만 반환할 때 사용

- index_subquery

  - WHERE 조건절에서 사용될 수 있는 IN (subquery) 형태의 쿼리를 위한 접근 방식, 서브 쿼리에서 중복된 값을 인덱스를 이용해 제거 할 수 있을 때 사용

- range

  - 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미, 주로 <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색 할 때 사용
  - 우선순위는 낮은 편이지만 모든 쿼리가 이 접근 방법만 사용해도 어느 정도 성능은 보장

- index_merge

  - 2개 이상의 인덱스를 사용해 각각의 검색 결과를 만들어 낸 후 그 결과를 병합
  - 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어 짐
  - AND와 OR 연산이 복잡하게 연결된 쿼리에서는 제대로 최적화 되지 못할 때가 많음
  - 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않음
  - index_merge 접근 방식으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가적인 작업이 더 필요 함

- index

  - 인덱스 풀 스캔
  - 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교 했을때 비교하는 레코드 건수는 같지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작아서 풀 테이블 스캔보다는 효율적이므로 풀 테이블 스캔보다는 훨씬 효율적으로 처리 될 수 있음
  - 다음 조건 가운데 (첫번째 + 두번째) 조건을 충족하거나, (첫번째 + 세번째) 조건을 충족하는 쿼리
    - range나 const 또는 ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
    - 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우(즉, 데이터 파일을 읽지 않아도 되는 경우)
    - 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우(즉, 별도의 정렬 작업을 피할 수 있는 경우)

- ALL

  - 풀 테이블 스캔

> 리드 어헤드
>
> MySQL에서는 연속적으로 인접한 페이지가 연속해서 몇 번 읽히게 되면 백그라운드로 작동하는 읽기 스레드가 최대 한 번에 64개의 페이지씩 한꺼번에 디스크로부터 읽어들이기 때문에 한 번에 페이지 하나씩 읽어드리는 작업 보다는 상당히 빠르게 레코드를 읽을 수 있다. 이러한 작동 방식을 리드 어헤드라고 한다.

#### possible_keys

- 최적의 실행 계획을 만들기 위한 후보군

#### key

- 최종 선택된 실행 계획에서 사용하는 인덱스

#### key_len

- 다중 칼럼으로 구성된 인덱스에서 몇 바이트까지(몇개의 칼럼까지) 사용했는지 알려주는 값

#### ref

- type이 ref일때 참조 조건으로 사용된 값

- ref값이 **func** 일 경우 참조용으로 사용된는 값을 그대로 사용한 것이 아니라, 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조 됐다는 것을 의미

  > 가능하다면 MyQSL 서버가 변환을 하지 않도록 조인 칼럼의 타입은 일치시키는 편이 좋음

#### rows

- 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수

#### Extra

 

