# [SQL AnttiPatterns(개발자가 알아야 할 25가지 SQL 함정과 해법)](http://ebook.insightbook.co.kr/book/25)

## 2장 다중 값 속성 저장
### 안티패턴
- 쉼표로 구분된 목록에 저장

### 안티패턴 사용이 합당한 경우
- 애플리케이션에서 쉼표로 구분된 형식에 데이터를 필요로 하고, 목록 안의 개별 항목에 접근할 필요가 없을 수 있다. 비슷하게 애플리케이션이 다른 출처에서 쉼표로 구분된 형식으로 데이터를 받아 데이터베이스에 그대로 저장하고 나중에 동일한 형식으로 불러내야 하며, 목록 안의 개별 값을 분리할 필요가 없다면 안티패턴을 사용할 수 있다. 반정규화를 사용하기로 결정할 때는 보수적이어야 한다. 데이터베이스를 정규화하는 것이 먼저다. 정규화는 애플리케이션 코드를 좀더 융통성 있게 하고, 데이터베이스의 정합성을 유지할 수 있게 한다.

### 해법
- 교차 테이블(조인 테이블, 다대다 테이블, 매핑 테이블) 생성
    - 어떤 테이블이 FK로 두 테이블을 참조할 때 이를 교차 테이블이라고 한다.


## 3장 계층구조 저장 및 조회하기
### 안티패턴
- 항상 부모에 의존하기
    - 단계에 상관없이 후손들을 조회하기 어려우며, count(), sum()을 이용하기 어렵다. 또한, 노드의 삭제가 번거로울 수 있다.
### 안티패턴 사용이 합당한 경우
- DBMS에서 인접 목록 형식으로 저장된 계층구조를 위한 SQL 확장 기능을 지원할 경우 ex) WHIT절, Oracle의 START WITH와 CONNECT BY PRIOR 등
### 해법
- 경로 열거
    - 경로 컬럼에 부모 키값을 모두 나열 ex) 1/2/3/
    - 경로 열거는 쉼표로 구분된 목록에 저장과 비슷한 단점이 있다. 데이터 베이스는 경로가 올바르게 형성되도록 하거나 경로 값이 실제 노드에 대응되도록 강제할 수 없다. 컬럼의 사이즈 제한으로 깊이가 제한될 수 있다.
- 중첩 집합
    - 각 노드가 자기 자손의 집합에 대한 정보를 저장한다. nsleft, nsright 같은 컬럼명을 사용하다고 하면 nsleft는 모든 자식 노드의 nsleft는 보다 작고, nsright는 모든 자식의 nsright보다 크게 한다. nsleft 값이 현재 노드의 nsleft와 nsright사이에 있는 노드를 검색하면 자손을 얻을 수 있다.
        ```sql
        SELECT *
        FROM Comments AS c1
        JOIN Comments AS c2
        ON c1.nsleft BETWEEN c2.nsleft AND c2.nsright
        ```
    - 중첩 집합은 노드를 추가, 이동하는 것과 같은 트리 조작도 다른것에 비해 복잡하다.
- 클로저 테이블
    - 클로저 테이블은 부모-자식에 대한 경로만을 저장하는 것이 아니라, 별도의 테이블을 이용해 트리의 모든 경로를 저장한다.
        ```sql
        CREATE TABLE TreePaths {
            ancesotr BIGINT NOT NULL,
            descendant BIGINT NOT NULL
            ...
        }
        ```

        ```sql
        -- 자손 조회
        SELECT *
        FROM Comments AS c
        JOIN TreePaths AS t ON c.comment_id = t.descendant
        ```

## 4장 PK 관례 확립
### 안티패턴
- 만능키
    - PK 칼럼 이름은 id이고 데이터 타입은 32비트 또는 64비트 정수이며 유일한 값은 자동 생성된다는 관례에 따라 모든 테이블에 추가되는 것
    - 중복키 생성 : 테이블 안의 다른 칼럼이 자연키로 사용될 수 있는 상황에서 통념에 따라 id 칼럼을 PK로 정의하는 경우 동일한 의미(PK)의 컬럼이 존재하게 됨
    - 중복 행 허용 : 복합키를 사용할 수 있는 상황에서 id 칼럼을 PK로 정의하는 경우 별도로 UNIQUE를 지정해주지 않으면 중복 행 발생
    - 모호한 키의 의미 : id란 이름은 아무런 의미도 갖지 못함
    - USING 사용 : FK 칼럼 이름을 별도로 지정해야 하므로 USING 사용 불가
### 안티패턴 사용이 합당한 경우
- 지나치게 긴 자연키를 대체, 많은 수의 복합키
### 해법
- PK는 의미 있는 이름을 선택. FK에서도 가능하다면 같은 컬럼 이름을 사용(연결의 본질을 더 잘 표현하는 경우라면 별도의 이름 허용)

## 5장 데이터베이스 아키텍처 단순화
### 안티패턴
- 제약조건 무시
### 해법
- 제약조건 선언하기

## 6장 가변 속성 지원
### 안티패턴
- 범용 속성 테이블 사용(엔티티-속성-값, EAV)
### 안티패턴 사용이 합당한 경우
- 비관계형 데이터 관리가 필요하다면 비관계형 기술을 사용해라
### 해법
- 서브타입 모델링
    - 단일 테이블 상속
    - 구체 테이블 상속
    - 클래스 테이블 상속

## 7장 여러 부모 참조(다형성 연관)
### 안티패턴
- 이중 목적의 FK 사용(하나의 컬럼이 여러테이블을 참조해야할 경우)
### 해법
- 관계 단순화
    - 각 부모에 대해 별도의 교차 테이블을 생성하여 FK 추가
    - 모든 부모 테이블이 상속할 베이스 테이블을 생성하고 자식 테이블이 베이스 테이블을 참조하는 FK 추가

## 8장 다중 값 속성 저장 (ex. tag)
### 안티패턴
- 여러 개의 칼럼 생성
### 해법
- 종속 테이블 생성

## 9장 확장 적응성 지원(많은 데이터양 지원)
### 안티패턴
- 테이블 또는 칼럼 복제
### 안티패턴 사용이 합당한 경우
- 매일 사용하는 데이터와 오래된 데이터 분리
### 해법
- 파티션과 정규화
    - 수평 분할 사용 : DB에서 제공
    ```sql
    CREATE TABLE Bugs (
        bug_id SERIAL PRIMARY KEY, ...
        date_reported DATE
    ) PARTITION BY HASH (YEAR(date_reported))
    PARTITIONS 4;
    ```
    - 수직 분할 사용 : BLOB와 TEXT 같은 크기가 가변적이고 매우 커질 수 있는 칼럼은 별도의 테이블로 분리










